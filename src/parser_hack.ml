(*
  !!! テスト用です
  !!! lexerが正常に動作することを確認したら削除する
*)


type token =
  | AND of (Range.t * Types.token_data)
  | AS of (Range.t * Types.token_data)
  | BLOCK of (Range.t * Types.token_data)
  | COMMAND of (Range.t * Types.token_data)
  | ELSE of (Range.t * Types.token_data)
  | END of (Range.t * Types.token_data)
  | FALSE of (Range.t * Types.token_data)
  | FUN of (Range.t * Types.token_data)
  | IF of (Range.t * Types.token_data)
  | IN of (Range.t * Types.token_data)
  | INCLUDE of (Range.t * Types.token_data)
  | INLINE of (Range.t * Types.token_data)
  | LET of (Range.t * Types.token_data)
  | MOD of (Range.t * Types.token_data)
  | MATCH of (Range.t * Types.token_data)
  | MATH of (Range.t * Types.token_data)
  | MODULE of (Range.t * Types.token_data)
  | MUTABLE of (Range.t * Types.token_data)
  | OF of (Range.t * Types.token_data)
  | OPEN of (Range.t * Types.token_data)
  | REC of (Range.t * Types.token_data)
  | SIG of (Range.t * Types.token_data)
  | SIGNATURE of (Range.t * Types.token_data)
  | STRUCT of (Range.t * Types.token_data)
  | THEN of (Range.t * Types.token_data)
  | TRUE of (Range.t * Types.token_data)
  | TYPE of (Range.t * Types.token_data)
  | VAL of (Range.t * Types.token_data)
  | WITH of (Range.t * Types.token_data)
  | PERSISTENT of (Range.t * Types.token_data)
  | BAR of (Range.t * Types.token_data)
  | WILDCARD of (Range.t * Types.token_data)
  | COLON of (Range.t * Types.token_data)
  | ARROW of (Range.t * Types.token_data)
  | REVERSED_ARROW of (Range.t * Types.token_data)
  | SEMICOLON of (Range.t * Types.token_data)
  | COMMA of (Range.t * Types.token_data)
  | CONS of (Range.t * Types.token_data)
  | ACCESS of (Range.t * Types.token_data)
  | QUESTION of (Range.t * Types.token_data)
  | COERCE of (Range.t * Types.token_data)
  | L_PAREN of (Range.t * Types.token_data)
  | R_PAREN of (Range.t * Types.token_data)
  | L_SQUARE of (Range.t * Types.token_data)
  | R_SQUARE of (Range.t * Types.token_data)
  | L_RECORD of (Range.t * Types.token_data)
  | R_RECORD of (Range.t * Types.token_data)
  | L_BLOCK_TEXT of (Range.t * Types.token_data)
  | R_BLOCK_TEXT of (Range.t * Types.token_data)
  | L_INLINE_TEXT of (Range.t * Types.token_data)
  | R_INLINE_TEXT of (Range.t * Types.token_data)
  | L_MATH_TEXT of (Range.t * Types.token_data)
  | R_MATH_TEXT of (Range.t * Types.token_data)
  | L_INLINE_TEXT_LIST of (Range.t * Types.token_data)
  | R_INLINE_TEXT_LIST of (Range.t * Types.token_data)
  | L_MATH_TEXT_LIST of (Range.t * Types.token_data)
  | R_MATH_TEXT_LIST of (Range.t * Types.token_data)
  | EXACT_MINUS of (Range.t * Types.token_data)
  | EXACT_TIMES of (Range.t * Types.token_data)
  | EXACT_AMP of (Range.t * Types.token_data)
  | EXACT_TILDE of (Range.t * Types.token_data)
  | EXACT_EQ of (Range.t * Types.token_data)
  | BINOP_TIMES of (Range.t * Types.token_data * Types.var_name)
  | BINOP_DIVIDES of (Range.t * Types.token_data * Types.var_name)
  | BINOP_PLUS of (Range.t * Types.token_data * Types.var_name)
  | BINOP_MINUS of (Range.t * Types.token_data * Types.var_name)
  | BINOP_HAT of (Range.t * Types.token_data * Types.var_name)
  | BINOP_AMP of (Range.t * Types.token_data * Types.var_name)
  | BINOP_BAR of (Range.t * Types.token_data * Types.var_name)
  | BINOP_GT of (Range.t * Types.token_data * Types.var_name)
  | BINOP_LT of (Range.t * Types.token_data * Types.var_name)
  | BINOP_EQ of (Range.t * Types.token_data * Types.var_name)
  | UNOP_EXCLAM of (Range.t * Types.token_data * Types.var_name)
  | LOWER of (Range.t * Types.token_data * Types.var_name)
  | UPPER of (Range.t * Types.token_data * Types.constructor_name)
  | LONG_LOWER of (Range.t * Types.token_data * Types.module_name list * Types.var_name Types.ranged)
  | LONG_UPPER of (Range.t * Types.token_data * Types.module_name list * Types.constructor_name Types.ranged)
  | BACKSLASH_CMD of (Range.t * Types.token_data * Types.command_name)
  | PLUS_CMD of (Range.t * Types.token_data * Types.command_name)
  | LONG_BACKSLASH_CMD of (Range.t * Types.token_data * Types.module_name list * Types.command_name Types.ranged)
  | LONG_PLUS_CMD of (Range.t * Types.token_data * Types.module_name list * Types.command_name Types.ranged)
  | VAR_IN_TEXT of (Range.t * Types.token_data * Types.module_namelist * Types.var_name Types.ranged)
  | TYPEVAR of (Range.t * Types.token_data * Types.type_variable_name)
  | ROWVAR of (Range.t * Types.token_data * Types.row_variable_name)
  | INT of (Range.t * Types.token_data * int)
  | FLOAT of (Range.t * Types.token_data * float)
  | LENGTH of (Range.t * Types.token_data * float * Types.length_unit_name)
  | CHAR of (Range.t * Types.token_data * string)
  | STRING of (Range.t * Types.token_data * string * bool * bool)
  | POSITIONED_STRING of (Range.t * Types.token_data * Types.input_position * string)
  | SPACE of (Range.t * Types.token_data)
  | BREAK of (Range.t * Types.token_data)
  | MATHCHARS of (Range.t * Types.token_data * string)
  | PRIMES of (Range.t * Types.token_data * int)
  | SUBSCRIPT of (Range.t * Types.token_data)
  | SUPERSCRIPT of (Range.t * Types.token_data)
  | ITEM of (Range.t * Types.token_data * int)
  | HEADER_REQUIRE of (Range.t * Types.token_data * string)
  | HEADER_IMPORT of (Range.t * Types.token_data * string)
  | BACKSLASH_MACRO of (Range.t * Types.token_data * Types.macro_name)
  | PLUS_MACRO of (Range.t * Types.token_data * Types.macro_name)
  | LONG_BACKSLASH_MACRO of (Range.t * Types.token_data * Types.module_name list * Types.macro_name Types.ranged)
  | LONG_PLUS_MACRO of (Range.t * Types.token_data * Types.module_name list * Types.macro_name Types.ranged)
  | EOI of (Range.t * Types.token_data)
  [@@deriving show]

